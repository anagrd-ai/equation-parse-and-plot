# -*- coding: utf-8 -*-
"""Equation Parser.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fwHvtvgT7urfNON4RN_cpVSIBoIbUBIx
"""

import ast
import operator
import math
from enum import Enum, auto

class NodeType(Enum):
    NUMBER = auto()
    VARIABLE = auto()
    OPERATOR = auto()
    FUNCTION = auto()

class EquationParser:
    def __init__(self):
        self.operators = {
            ast.Add: operator.add,
            ast.Sub: operator.sub,
            ast.Mult: operator.mul,
            ast.Div: operator.truediv,
            ast.Pow: operator.pow,
            ast.USub: operator.neg
        }

        self.functions = {
            'sin': math.sin,
            'cos': math.cos,
            'tan': math.tan,
            'exp': math.exp,
            'log': math.log,
            'sqrt': math.sqrt
        }

    def parse_equation(self, equation_string):
        if equation_string.startswith('z ='):
            equation_string = equation_string[3:].strip()
        try:
            return ast.parse(equation_string, mode='eval')
        except SyntaxError as e:
            raise ValueError(f"Invalid equation syntax: {e}")

    def tokenize_equation(self, equation_string):
        parsed_eq = self.parse_equation(equation_string)
        return self._tokenize_node(parsed_eq.body)

    def _tokenize_node(self, node):
        if isinstance(node, ast.Num):
            return (NodeType.NUMBER, node.n)
        elif isinstance(node, ast.Name):
            return (NodeType.VARIABLE, node.id)
        elif isinstance(node, ast.BinOp):
            return (NodeType.OPERATOR, type(node.op),
                    self._tokenize_node(node.left),
                    self._tokenize_node(node.right))
        elif isinstance(node, ast.UnaryOp):
            return (NodeType.OPERATOR, type(node.op),
                    self._tokenize_node(node.operand))
        elif isinstance(node, ast.Call):
            return (NodeType.FUNCTION, node.func.id,
                    [self._tokenize_node(arg) for arg in node.args])
        else:
            raise ValueError(f"Unsupported node type: {type(node)}")

    def evaluate_equation(self, tokenized_eq, x, y):
        r = math.sqrt(x*x + y*y)  # Slight optimization: x*x instead of x**2
        return self._evaluate_node(tokenized_eq, {'x': x, 'y': y, 'r': r})

    def _evaluate_node(self, node, variables):
        node_type = node[0]
        if node_type is NodeType.NUMBER:
            return node[1]
        elif node_type is NodeType.VARIABLE:
            return variables[node[1]]
        elif node_type is NodeType.OPERATOR:
            op = self.operators[node[1]]
            if len(node) == 3:
                return op(self._evaluate_node(node[2], variables))
            else:
                return op(self._evaluate_node(node[2], variables),
                          self._evaluate_node(node[3], variables))
        elif node_type is NodeType.FUNCTION:
            func = self.functions[node[1]]
            args = [self._evaluate_node(arg, variables) for arg in node[2]]
            return func(*args)
        else:
            raise ValueError(f"Unsupported node type: {node_type}")

# Optimize frequently used functions
sin = math.sin
cos = math.cos

# Example usage
parser = EquationParser()

def parse_and_tokenize(equation_string):
    return parser.tokenize_equation(equation_string)

def evaluate(tokenized_eq, x, y):
    return parser.evaluate_equation(tokenized_eq, x, y)

# Test the functions
if __name__ == "__main__":
    import timeit

    equations = [
        "2 * x + sin(y) - 3 * sqrt(x**2 + y**2)",
        "r * sin(y/x)",
        "x * cos(r) + y * sin(r)"
    ]

    x, y = 3, 4

    for eq_string in equations:
        tokenized = parse_and_tokenize(eq_string)
        result = evaluate(tokenized, x, y)
        print(f"z(x, y) = {eq_string}\nz({x}, {y}) = {result}")

        # Measure performance
        time = timeit.timeit(lambda: evaluate(tokenized, x, y), number=100000)
        print(f"Evaluation time for 100,000 iterations: {time:.4f} seconds")
        result = evaluate(tokenized, x, y)

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D


def plot_equation_3d(equation_string, x_range=(-2, 2), y_range=(-2, 2), resolution=50):
    """
    Evaluate the equation over a range of x and y values and create a 3D mesh plot.

    :param equation_string: The equation to evaluate (as a string)
    :param x_range: Tuple of (min_x, max_x)
    :param y_range: Tuple of (min_y, max_y)
    :param resolution: Number of points along each axis
    """
    # Parse the equation
    tokenized_eq = parse_and_tokenize(equation_string)

    # Create x and y values
    x = np.linspace(x_range[0], x_range[1], resolution)
    y = np.linspace(y_range[0], y_range[1], resolution)
    X, Y = np.meshgrid(x, y)

    # Evaluate the equation for all x and y values
    Z = np.zeros_like(X)
    for i in range(resolution):
        for j in range(resolution):
            Z[i, j] = evaluate(tokenized_eq, X[i, j], Y[i, j])

    # Create the 3D plot
    fig = plt.figure(figsize=(10, 8))
    ax = fig.add_subplot(111, projection='3d')

    # Plot the surface
    surf = ax.plot_surface(X, Y, Z, cmap='viridis', edgecolor='none', alpha=0.8)

    # Customize the plot
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Z')
    ax.set_title(f'3D Plot of z = {equation_string}')

    # Add a color bar
    fig.colorbar(surf, ax=ax, shrink=0.5, aspect=5)

    plt.show()

# Example usage
if __name__ == "__main__":
    equations = [
        "2 * cos(r)",
        "tan(r)",
        "x * y"
    ]

    for eq in equations:
        plot_equation_3d(eq)

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

class InteractivePlotter:
    def __init__(self, equation_string, x_range=(-2, 2), y_range=(-2, 2), resolution=50):
        self.equation_string = equation_string
        self.x_range = x_range
        self.y_range = y_range
        self.resolution = resolution
        self.high_res_mode = False
        self.parser = EquationParser()
        self.tokenized_eq = parser.tokenize_equation(equation_string)

        self.fig = plt.figure(figsize=(10, 8))
        self.ax = self.fig.add_subplot(111, projection='3d')

        self.plot()
        self.setup_interactions()

    def evaluate_equation(self):
        x = np.linspace(self.x_range[0], self.x_range[1], self.resolution)
        y = np.linspace(self.y_range[0], self.y_range[1], self.resolution)
        X, Y = np.meshgrid(x, y)
        Z = np.vectorize(lambda x, y: evaluate(self.tokenized_eq, x, y))(X, Y)
        return X, Y, Z

    def plot(self):
        self.ax.clear()
        X, Y, Z = self.evaluate_equation()

        if self.high_res_mode:
            surf = self.ax.plot_surface(X, Y, Z, cmap='viridis', edgecolor='none', alpha=0.8, shade=False)
        else:
            surf = self.ax.plot_surface(X, Y, Z, cmap='viridis', edgecolor='black', alpha=0.8, linewidth=0.5)

        self.ax.set_xlabel('X')
        self.ax.set_ylabel('Y')
        self.ax.set_zlabel('Z')
        self.ax.set_title(f'3D Plot of z = {self.equation_string}')

        self.fig.colorbar(surf, ax=self.ax, shrink=0.5, aspect=5)
        plt.draw()

    def setup_interactions(self):
        self.fig.canvas.mpl_connect('button_press_event', self.on_press)
        self.fig.canvas.mpl_connect('button_release_event', self.on_release)
        self.fig.canvas.mpl_connect('motion_notify_event', self.on_motion)
        self.fig.canvas.mpl_connect('key_press_event', self.on_key)

    def on_press(self, event):
        self.mouse_pressed = True
        self.last_x = event.xdata
        self.last_y = event.ydata

    def on_release(self, event):
        self.mouse_pressed = False

    def on_motion(self, event):
        if self.mouse_pressed and event.inaxes == self.ax:
            dx = event.xdata - self.last_x
            dy = event.ydata - self.last_y
            self.ax.view_init(elev=self.ax.elev + dy*0.5, azim=self.ax.azim - dx*0.5)
            plt.draw()
            self.last_x = event.xdata
            self.last_y = event.ydata

    def on_key(self, event):
        if event.key == 'left':
            self.ax.view_init(elev=self.ax.elev, azim=self.ax.azim - 10)
        elif event.key == 'right':
            self.ax.view_init(elev=self.ax.elev, azim=self.ax.azim + 10)
        elif event.key == '+':
            self.ax.set_box_aspect((1, 1, self.ax.get_box_aspect()[2]*0.9))
        elif event.key == '-':
            self.ax.set_box_aspect((1, 1, self.ax.get_box_aspect()[2]*1.1))
        elif event.key == 'g':
            self.high_res_mode = not self.high_res_mode
            self.resolution = 100 if self.high_res_mode else 50
            self.plot()
        plt.draw()

def plot_equation_3d_interactive(equation_string, x_range=(-2, 2), y_range=(-2, 2), resolution=50):
    plotter = InteractivePlotter(equation_string, x_range, y_range, resolution)
    plt.show()

# Example usage
if __name__ == "__main__":
    equations = [
        "2 * x + sin(y) - 3 * sqrt(x**2 + y**2)",
        "r * sin(y/x)",
        "x * cos(r) + y * sin(r)"
    ]

    for eq in equations:
        plot_equation_3d_interactive(eq)